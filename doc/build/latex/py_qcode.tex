% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{py_qcode Documentation}
\date{May 04, 2014}
\release{0.0}
\author{Ben Criger}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Simulation}
\label{simulation:py-qcode-decoding-topological-error-correcting-codes-in-python}\label{simulation::doc}\label{simulation:simulation}

\section{Class Reference}
\label{simulation:class-reference}\index{Simulation (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{simulation:py_qcode.Simulation}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{Simulation}}{\emph{lattice}, \emph{error\_model}, \emph{code}, \emph{decoder}, \emph{n\_trials}}{}
\emph{Simulation} is the top-level class
for py\_qcode, the user is meant to set up, execute and save results
using these objects.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{error\_model} (\code{py\_qcode:ErrorModel}, input) -- A description of the errors to be applied independently to the qubits of \emph{lattice}.

\item {} 
\textbf{code} ({\hyperref[code:py_qcode.ErrorCorrectingCode]{\code{py\_qcode.ErrorCorrectingCode}}}, input) -- An error-correcting code which translates errors on a lattice to syndromes on the dual lattice.

\item {} 
\textbf{decoder} ({\hyperref[decoder:py_qcode.Decoder]{\code{py\_qcode.Decoder}}}, input) -- A protocol for inferring errors given syndromes.

\item {} 
\textbf{n\_trials} (\emph{integer, input}) -- a number of simulations to be performed in series. This can be used to organize batch jobs so that one can submit more than one simulation per job.

\item {} 
\textbf{true\_coset} (\emph{str, output}) -- The actual coset to which the random error applied in the simulation belongs.

\item {} 
\textbf{inferred\_coset} -- The coset assigned by the error-correcting code during the simulation.

\end{itemize}

\end{description}\end{quote}
\index{run() (py\_qcode.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{simulation:py_qcode.Simulation.run}\pysiglinewithargsret{\bfcode{run}}{}{}
The main routine in this library, follows the recipe \emph{n\_trials} times in series:
\begin{itemize}
\item {} 
Apply the error model to the primary lattice, assigning values to the \emph{error} attributes of the {\hyperref[lattice:py_qcode.Point]{\code{py\_qcode.Point}}} objects within.

\item {} 
Obtain the true coset of the error with respect to the {\hyperref[code:py_qcode.ErrorCorrectingCode]{\code{py\_qcode.ErrorCorrectingCode}}} being used.

\item {} 
Perform a measurement, using the attributes of the error-correcting code to generate syndromes on the dual lattice.

\item {} 
Infer the coset of the error by acting the decoder on the dual lattice.

\item {} 
Record both cosets.

\end{itemize}

\end{fulllineitems}

\index{save() (py\_qcode.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{simulation:py_qcode.Simulation.save}\pysiglinewithargsret{\bfcode{save}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\chapter{Lattices}
\label{lattice:lattices}\label{lattice::doc}

\section{Class Reference}
\label{lattice:class-reference}\index{Point (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{lattice:py_qcode.Point}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{Point}}{\emph{coords}, \emph{error=None}, \emph{syndrome=None}}{}
Represents a point in two or three dimensions. Normally, I'd use a
\code{namedtuple}, because I'm not a psychopath, but I want to use
default arguments without getting too fancy. Each point can also 
contain a value denoting the error which an 
\code{ErrorModel} has applied to that point, and/or a
syndrome which results from measurement of an
\code{ErrorCorrectingCode} on the lattice.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{coords} (\emph{tuple of ints, length 2 or 3}) -- co-ordinates of the point in question.

\item {} 
\textbf{error} (\emph{any}) -- A value which denotes an error. An \code{ErrorCorrectingCode} must check that this value corresponds to an operator which can be translated into a syndrome.

\item {} 
\textbf{syndrome} (\emph{any}) -- A value which denotes an syndrome. A \code{Decoder} must check that this value corresponds to an operator which can be translated into a syndrome.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Lattice (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{lattice:py_qcode.Lattice}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{Lattice}}{\emph{sz\_tpl}, \emph{is\_3D=False}, \emph{closed\_boundary=True}}{}
A collection of points. Superclass to \code{SquareLattice}, \code{SquareOctagonLattice}, \code{UnionJackLattice}, whatever other convenient lattices I put in.

Represents a 2D/3D lattice of points with integer 
co-ordinates on which a stabilizer code can be defined.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sz\_tpl} (\emph{tuple, length 2 or 3, containing integers.}) -- linear dimensions of the lattice.

\item {} 
\textbf{is\_3D} (\emph{bool}) -- indicates whether the lattice is to be two- or three- dimensional.

\item {} 
\textbf{closed\_boundary} (\emph{bool}) -- Indicates whether to identify the Nth co-ordinate with the zeroth co-ordinate in every dimension.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{SquareLattice (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{lattice:py_qcode.SquareLattice}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{SquareLattice}}{\emph{sz\_tpl}, \emph{is\_3D=False}, \emph{closed\_boundary=True}, \emph{rough\_sides=(`f'}, \emph{`b')}}{}
Represents a lattice in which qubits are placed on the edges of a grid of squares.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{rough\_sides} (\emph{tuple of strings}) -- Denotes which, if any, of the sides of the lattice are to have `rough' boundary conditions. Values in \code{rough\_sides} must be drawn from \code{{[}'u', 'd', 'r', 'l', 'f', 'b'{]}} (up, down, left, right, front, back).

\end{description}\end{quote}

\end{fulllineitems}

\index{SquareOctagonLattice (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{lattice:py_qcode.SquareOctagonLattice}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{SquareOctagonLattice}}{\emph{sz\_tpl}, \emph{is\_3D=False}, \emph{closed\_boundary=True}}{}
Represents a lattice in which qubits are placed on the corners of squares and octagons.

\end{fulllineitems}

\index{UnionJackLattice (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{lattice:py_qcode.UnionJackLattice}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{UnionJackLattice}}{\emph{sz\_tpl}}{}
Represents a lattice in which qubits are placed on the intersections of the diagonals of squares, as well as their corners.

\end{fulllineitems}



\chapter{Error Correcting Codes}
\label{code:error-correcting-codes}\label{code::doc}

\section{Class Reference}
\label{code:class-reference}\index{ErrorCorrectingCode (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{code:py_qcode.ErrorCorrectingCode}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{ErrorCorrectingCode}}{\emph{arg}}{}
An error-correcting code, for the purpose of this module, is a rule
for taking errors on sets of points, and turning them into
discrete-valued syndromes which are interpreted by the decoder.
Normally, we would immediately make the restriction to stabilizer
codes which return binary-valued syndromes, but we want to make
room for codes which correct non-Pauli errors, and return fuzzy
syndromes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{primal\_lattice} ({\hyperref[lattice:py_qcode.Lattice]{\code{py\_qcode.Lattice}}}) -- The lattice on which the qubits live.

\item {} 
\textbf{dual\_lattice} ({\hyperref[lattice:py_qcode.Lattice]{\code{py\_qcode.Lattice}}}) -- The lattice on which the parity checks live.

\item {} 
\textbf{parity\_check} (\emph{function}) -- A rule for mapping errors on the primal lattice to measurement results on the dual lattice.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{StabilizerCode (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{code:py_qcode.StabilizerCode}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{StabilizerCode}}{\emph{arg}}{}
subclass of
ErrorCorrectingCode for which syndromes are determined by commutation
/anti-commutation with a Pauli stabilizer.

\end{fulllineitems}



\chapter{Error Models}
\label{error:error-models}\label{error::doc}

\section{Class Reference}
\label{error:class-reference}\index{ErrorModel (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{error:py_qcode.ErrorModel}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{ErrorModel}}{\emph{prob\_op\_list}}{}
Wraps a list of tuples corresponding to a discrete probability and an operator. This assumes independent identically-distributed noise, though not necessarily Pauli.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{prob\_op\_list} (\emph{list}) -- A list of probabilites and associated operators. The probabilites are floats which must sum to 1 to within $10^{-12}$. The operators are represented by strings which must be drawn from the list of acceptable operators \emph{{[}'I','X','Y','Z','H','P'{]}} Each pair (a probability and its associated operator) is stored in a tuple.

\end{description}\end{quote}

\end{fulllineitems}

\index{DepolarizingModel (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{error:py_qcode.DepolarizingModel}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{DepolarizingModel}}{\emph{p}}{}
The depolarizing model applies the identity with probability $1-p$, and each of the single qubit Pauli operators $X$, $Y$, and $Z$ with probability $\dfrac{p}{3}$.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{p} (\emph{float}) -- A probability, between 0 and 1.

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Decoders}
\label{decoder:decoders}\label{decoder::doc}

\section{Class Reference}
\label{decoder:class-reference}\index{Decoder (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{decoder:py_qcode.Decoder}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{Decoder}}{\emph{arg}}{}
docstring for Decoder

\end{fulllineitems}

\index{MWPMDecoder (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{decoder:py_qcode.MWPMDecoder}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{MWPMDecoder}}{\emph{arg}}{}
docstring for MWPMDecoder

\end{fulllineitems}

\index{RGBPDecoder (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{decoder:py_qcode.RGBPDecoder}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{RGBPDecoder}}{\emph{arg}}{}
docstring for RGBPDecoder

\end{fulllineitems}

\index{BHRGDecoder (class in py\_qcode)}

\begin{fulllineitems}
\phantomsection\label{decoder:py_qcode.BHRGDecoder}\pysiglinewithargsret{\strong{class }\code{py\_qcode.}\bfcode{BHRGDecoder}}{\emph{arg}}{}
docstring for BHRGDecoder

\end{fulllineitems}



\chapter{Introduction}
\label{index:introduction}
This library is concerned with simulating the decoding of topological quantum error-correcting codes. This is useful for determining their threshold error rates and logical error rates in the regime where useful error correction can be performed. In order to simulate the act of decoding, the following components are necessary:
\begin{itemize}
\item {} 
\textbf{Input/Output}: Routines to input necessary values such as the name of the lattice geometry, size, error-correcting code to be used, etc., and save the resulting  output to a file.

\item {} 
\textbf{Lattice}: A set of points on which the qubits and stabilizers of the code are defined.

\item {} 
\textbf{Error Model}: A set of Gottesman-Knill-compliant operators and probabilities with which they are applied to the qubits in the lattice.

\item {} 
\textbf{Error-Correcting Code}: A set of stabilizer generators, along with their support, which produces error syndromes given an error.

\item {} 
\textbf{Decoder}: A rule for inferring the original error, given a syndrome.

\end{itemize}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
